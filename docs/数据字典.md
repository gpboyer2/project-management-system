# 数据字典汇总

## 1.体系建模

### 1.1 node_types （节点类型字典）

**说明**

`node_types` 表是一个基础字典表，用于定义体系架构树中所有节点的类型。用户可通过层级设置页面自定义节点类型，为 `arch_tree_nodes` 表中的每个节点提供分类依据，从而确保了系统模型的统一性和可扩展性。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| id | 类型ID | 类型的唯一标识符 | BIGINT UNSIGNED | - | ≥0 | 主键, 自增 | - |
| type_name | 类型名称 | 类型的程序内名称 | VARCHAR | 50 | - | 唯一, 不允许为空 | - |
| display_name | 显示名称 | 用于UI显示的名称 | VARCHAR | 100 | - | 不允许为空 | - |
| icon_class | 图标类名 | 关联的前端图标CSS类名 | VARCHAR | 100 | - | 可为空 | - |
| description | 描述 | 对该类型的描述 | TEXT | - | - | 可为空 | - |
| created_at | 创建时间 | 记录创建时间 | Datetime | - | - | 不为空, 更新时自动更新 | - |
| updated_at | 更新时间 | 记录最后更新时间 | Datetime | - | - | 不为空, 更新时自动更新 | - |

**示例数据:**

> 注意：以下仅为示例，实际数据由用户在层级设置页面配置。

|id|type_name|display_name|icon_class|
|---|---|---|---|
|1|'ROOT'|'根节点'|'icon-folder'|
|2|'CATEGORY_A'|'分类A'|'icon-category'|
|3|'CATEGORY_B'|'分类B'|'icon-item'|

### 1.2 arch_tree_nodes（体系树节点表）

**说明**

`arch_tree_nodes` 表是定义系统层级结构的**核心实体表**。它通过自引用的 `parent_id` 字段，构建了一个无限深度的树状模型，用于表示完整的体系架构。表中的每一行都代表一个架构实体，其具体类型由 `node_type_id` 关联到 `node_types` 表来确定。这种设计使得系统能够灵活地表示和管理复杂的层级关系。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| id | 节点ID | 节点的唯一标识符 | BIGINT UNSIGNED | - | ≥0 | 主键, 自增 | - |
| parent_id | 父节点ID | 指向父节点ID，根节点为NULL | BIGINT UNSIGNED | - | ≥0 | - | 外键: `arch_tree_nodes(id)` |
| node_type_id | 节点类型ID | 表示此节点的类型 | BIGINT UNSIGNED | - | ≥0 | 不允许为空 | 外键: `node_types(id)` |
| name | 节点名称 | 节点的名称 | VARCHAR | 255 | - | 不允许为空, 同级唯一 | - |
| description | 描述 | 节点的详细描述 | TEXT | - | - | 可为空 | - |
| created_at | 创建时间 | 记录创建时间 | Datetime | - | - | 不为空, 更新时自动更新 | - |
| updated_at | 更新时间 | 记录最后更新时间 | Datetime | - | - | 不为空, 更新时自动更新 | - |

说明：`(parent_id, name)`确保唯一，确保同级节点名称唯一。

### 1.3 communication_nodes（通信节点/流程元数据表）

**说明**

`communication_nodes` 表是流程的**核心元数据表**。它专注于记录流程的业务属性和身份信息，而将所有与物理存储相关的细节剥离出去。通过 `flow_digest_sha256` 字段，它与实际的物理文件（无论存储在哪里）建立逻辑关联。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| id | 通信节点ID | 通信节点的唯一标识；对应一份可执行的流程定义元数据实体。 | BIGINT UNSIGNED | 64位 | ≥0 | 主键，自动递增，不为空 | - |
| node_id | 所属节点ID | 指向架构树中的节点；将通信节点归属到具体节点实体与部署环境。 | BIGINT UNSIGNED | 64位 | ≥0 | 外键，不为空 | 关联 `arch_tree_nodes.id` |
| name | 通信节点名称 | 业务可读名称，用于展示、检索与权限控制；同一节点下唯一。 | VARCHAR | 255 | - | 不为空；唯一约束 `(node_id, name)` | - |
| endpoint_description | 端点描述 (JSON) | 从 Flow 文件中提取的、用于UI展示和检索的连接端点描述（数组形式）。非权威，仅供参考。 | JSON | - | - | 可为空 | - |
| status | 节点状态 | 生命周期状态。 | VARCHAR | 50 | `active`/`inactive`/`error`/`deprecated` | 默认 `active`，不为空 | - |
| config | 配置（JSON） | 可选的流程/节点配置快照（小体积预览或差异），用于界面展示与比对。 | JSON | - | - | 可为空 | - |
| flow_version | 流程版本号 | 标识流程演进版本，用于变更管控与回滚。 | VARCHAR | 50 | 语义化版本 | 不为空，默认 `1.0.0` | - |
| flow_digest_sha256 | 流程内容摘要 | 内容哈希（SHA-256），作为内容的唯一“指纹”，用于完整性校验与内容寻址。 | VARCHAR | 64 | 十六进制 | 不为空 | - |
| size_bytes | 文件大小（字节） | 记录内容体积，便于容量控制与阈值策略。 | BIGINT UNSIGNED | 64位 | ≥0 | 不为空 | - |
| *run_mode* | *运行模式(?)* | *执行隔离级别。* | *VARCHAR* | *20* | *`main_thread`/`independent_thread`/`independent_process`* | *默认 `main_thread`，不为空* | *-* |
| created_at | 创建时间 | 记录创建时间。 | Datetime | - | - | 不为空, 更新时自动更新 | - |
| updated_at | 更新时间 | 最近一次更新。 | Datetime | - | - | 不为空, 更新时自动更新 | - |

> 约束建议：
> - 索引：`(node_id, name)` 唯一索引；`flow_digest_sha256` 普通索引；`node_id` 外键索引。

**关键数据示例**

当用户在低代码平台保存一个流程时，后端服务在保存 Flow 文件的同时，会解析文件内容，提取**所有**关键的通信端点信息，并将它们作为一个**数组**存入 `endpoint_description` 字段。

示例 1: 简单的数据采集流程 (单一输入)

该流程仅通过串口接收传感器数据。

-   `endpoint_description`:
    ```json
    [
      {
        "role": "input",
        "type": "Serial",
        "port_name": "/dev/ttyS0",
        "baud_rate": 9600
      }
    ]
    ```

示例 2: 复杂的数据桥接流程 (一个输入, 两个输出)

该流程通过 UDP 组播接收数据，经过处理后，一份数据通过 TCP 客户端发送出去，另一份通过串口发送。

-   `endpoint_description`:
    ```json
    [
      {
        "role": "input",
        "type": "UDP Multicast",
        "group": "239.1.1.100",
        "port": 12345
      },
      {
        "role": "output",
        "type": "TCP Client",
        "remote_host": "192.168.1.200",
        "remote_port": 5000
      },
      {
        "role": "output",
        "type": "Serial",
        "port_name": "/dev/ttyUSB0",
        "baud_rate": 115200
      }
    ]
    ```

### 1.4 connection_endpoint_pairs（连接配对）

**说明**

`connection_endpoint_pairs` 表用于显式记录系统中两个通信节点（`communication_nodes`）之间的**物理连接关系**。它定义了数据流动的方向，明确了哪个节点是数据源（`source_comm_node_id`），哪个是目标（`target_comm_node_id`）。这张表是实现系统级数据链路可视化、依赖分析和影响追踪的**关键**。通过查询此表，可以快速构建出整个系统的通信拓扑图，从而为系统监控、调试和维护提供支持。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| id | 配对ID | 配对的唯一标识符 | BIGINT UNSIGNED | - | ≥0 | 主键, 自增 | - |
| source_comm_node_id | 源通信节点ID | 源通信节点的ID | BIGINT UNSIGNED | - | ≥0 | 不允许为空 | 外键: `communication_nodes(id)` |
| target_comm_node_id | 目标通信节点ID | 目标通信节点的ID | BIGINT UNSIGNED | - | ≥0 | 不允许为空 | 外键: `communication_nodes(id)` |
| description | 描述 | 对这个具体端点配对的描述 | TEXT | - | - | 可为空 | - |
| created_at | 创建时间 | 记录创建时间 | Datetime | - | - | 不为空, 更新时自动更新 | - |
| updated_at | 更新时间 | 记录最后更新时间 | Datetime | - | - | 不为空, 更新时自动更新 | - |

说明：`(source_comm_node_id, target_comm_node_id)`确保唯一，  确保一条概念连接下的端点配对不重复。 

## 2.公共数据字典

### 2.1 StorageEndpoint (存储端点)

**说明**

`StorageEndpoint` 表是整个系统的**存储配置中心**，用于统一定义所有可用的物理或逻辑存储位置。每个端点代表一个具体的存储后端，例如一个 S3 存储桶、一个 NFS 共享目录或一个 Artifactory 仓库。

通过将存储配置抽象化为“端点”，核心业务逻辑（如流程管理、代码生成、报文管理）与具体的存储实现完全解耦。这使得系统可以在不同环境（开发、测试、生产）中无缝切换存储策略，或在未来轻松引入新的存储技术，而无需修改上层应用代码。

| 字段 | 名称 | 含义 | 数据类型 | 约束条件 |
|---|---|---|---|---|
| endpoint_id | 端点ID | 主键，建议使用UUID | BIGINT UNSIGNED | 主键、不为空 |
| provider | 提供方 | 存储提供方枚举 | Enum(`s3`,`minio`,`nfs`,`localfs`,`nexus`,`artifactory`,`azure`,`gcs`,`http`) | 不为空 |
| endpoint_type | 端点类型 | 对提供方的分类 | Enum(`object_storage`,`filesystem`,`artifact_repo`) | 不为空 |
| base_uri | 基础URI | 端点的基础访问地址，如 `s3://bucket-name` 或 `file:///var/data/shared` | String(255) | 不为空 |
| is_active | 是否激活 | 标记该端点当前是否可用 | Boolean | 不为空, 默认 `true` |
| created_at | 创建时间 | 记录创建时间 | Datetime | 不为空 |
| updated_at | 更新时间 | 记录最后更新时间 | Datetime | 不为空, 更新时自动更新 |

### 2.2 AssetLocation (统一资产位置)

**说明**

AssetLocation 是一个统一的多态映射表，它通过记录每个资产（由 asset_id 和 asset_type 联合标识）所处的 StorageEndpoint 及其具体路径（object_key），将资产元数据与其物理存储位置连接起来。该表通过 is_primary 字段支持单一资产拥有多个存储副本，为数据冗余、灾备和就近访问等高级存储策略提供了基础。

| 字段 | 名称 | 含义 | 数据类型 | 约束条件 |
|---|---|---|---|---|
| location_id | 位置ID | 主键 | BIGINT UNSIGNED | 主键、不为空 |
| asset_id | 资产ID | 关联的资产记录 ID (例如 `communication_nodes.id`, `Artifact.artifact_id`, `MessageFormat.id`) | BIGINT | 不为空 |
| asset_type | 资产类型 | 关联的资产类型 | Enum(`FLOW`, `ARTIFACT`, `MESSAGE_FORMAT`, `CODE_SNIPPET`) | 不为空 |
| endpoint_id | 端点ID | 关联 `StorageEndpoint` | BIGINT UNSIGNED | 外键、不为空 |
| object_key | 对象Key | 在该端点内的相对路径/Key | String(1024) | 不为空 |
| is_primary | 主位置 | 是否为主/首选访问位置 | Boolean | 不为空、`(asset_id, asset_type, is_primary)` 唯一 |
| version_tag | 版本标签 | 资产的版本标记，如 `v1.0.0`, `latest`, `build-20251105` | String(64) | 可空 |
| artifact_type | 产物子类型 | 当一个资产包含多种文件时，用于区分具体文件类型。 | Enum(`DEFINITION_XML`, `GENERATED_HPP`, `GENERATED_CPP`, `SOURCE_PACKAGE`, `EXECUTABLE`, `SHARED_LIBRARY`) | 可空 |
| created_at | 创建时间 | 记录创建时间 | Datetime | 不为空, 更新时自动更新 |
| updated_at | 更新时间 | 记录最后更新时间 | Datetime | 不为空, 更新时自动更新 |
| decommissioned_at | 退役时间 | 失效时间（用于软删除），标记后可由后台任务安全清理 | Datetime | 可空 |

---

## 3.代码生成

### 3.1 GenerationTask（代码生成任务）

**说明**

`GenerationTask` 表是代码生成模块的**核心任务跟踪表**。它记录了每一次从可视化流程（由 `flow_id` 标识）到目标语言源代码的转换请求。此表的核心职责是管理代码生成任务的生命周期，从接收请求（`pending`）、执行转换（`processing`）到最终产出成功（`completed`）或失败（`failed`）。通过 `task_id`，系统可以精确追踪每个生成请求的状态和历史，为用户提供透明的进度反馈，并为后续的构建（`BuildTask`）和问题排查提供依据。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| task_id | 任务ID | 代码生成任务的唯一标识符。此ID用于跟踪从请求接收到代码生成完成的全过程，确保每个生成请求都能被独立追踪和管理。 | BIGINT UNSIGNED | 64位 | ≥0 | 主键, 不允许为空 | - |
| flow_id | 流程ID | 关联的可视化流程ID。此字段用于从流程数据库中获取需要生成代码的原始流程定义，是代码生成的直接输入源。 | BIGINT UNSIGNED | 64位 | ≥0 | 外键, 不允许为空 | 关联Flow表 |
| target_language | 目标语言 | 指定生成的代码语言。当前版本固定为C++11，但此字段为未来扩展至其他语言（如Python、Java）预留了接口。 | String | 20 | `cpp`, `python`, `java` | 不允许为空, 默认值 `cpp` | - |
| status | 任务状态 | 代码生成任务的当前状态。该状态反映了任务在生命周期中的位置，从排队等待到最终完成或失败，为用户提供了实时的进度反馈。 | String | 20 | `pending`, `processing`, `completed`, `failed` | 不允许为空, 默认值 `pending` | - |
| created_at | 创建时间 | 任务被创建的时间戳。记录了任务的初始请求时间，用于监控和审计。 | Datetime | - | - | 不允许为空 | - |
| updated_at | 更新时间 | 任务状态或元数据最近更新的时间戳。 | Datetime | - | - | 不允许为空, 更新时自动更新 | - |
| completed_at | 完成时间 | 任务完成或失败的时间戳。通过与创建时间对比，可以计算出任务的总耗时，用于性能分析和优化。 | Datetime | - | - | 允许为空 | - |

### 3.2 BuildTask（资产构建任务）

**说明**

`BuildTask` 表是**构建自动化**的核心，负责跟踪和管理将生成的源代码编译、链接为最终可执行产物（如 `.dll`, `.exe`, `.so`）的全过程。每个构建任务都与一个特定的代码生成任务（`generation_task_id`）关联，确保了从设计到产出的完整可追溯性。此表不仅记录了构建的状态（`pending`, `building`, `succeeded`, `failed`），还存储了详细的构建日志（`build_log`），这对于诊断编译错误和链接问题至关重要。通过 `build_id`，系统可以精确管理每一次构建活动，并为最终的产物（`Artifact`）提供来源证明。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| build_id | 构建ID | 代码构建任务的唯一标识符。此ID用于跟踪从代码编译到产物生成的全过程，确保每个构建请求都能被独立管理和追溯。 | BIGINT UNSIGNED | 64位 | ≥0 | 主键, 不允许为空 | - |
| generation_task_id | 代码生成任务ID | 关联的代码生成任务ID。此字段用于获取由代码生成任务产生的源代码，作为构建过程的输入。 | BIGINT UNSIGNED | 64位 | ≥0 | 外键, 不允许为空 | 关联GenerationTask表 |
| build_target | 构建目标 | 指定编译产物的类型。用户可以根据部署需求选择生成动态链接库（用于集成）或可执行文件（用于独立运行）。 | String | 20 | `dll`, `exe`, `so` | 不允许为空 | - |
| compiler_options | 编译选项 | 用户自定义的编译器配置。此字段允许高级用户传入特定的编译参数，如优化级别、宏定义等，以满足特殊的构建需求。 | Object | - | - | 允许为空 | - |
| status | 构建状态 | 代码构建任务的当前状态。该状态详细记录了构建过程的每一个阶段，从排队、编译到最终成功或失败，为问题排查提供依据。 | String | 20 | `pending`, `building`, `succeeded`, `failed` | 不允许为空, 默认值 `pending` | - |
| build_log | 构建日志 | 记录了编译器输出的详细日志。当构建失败时，日志是定位语法错误、链接错误或其他问题的关键信息。 | String | - | - | 允许为空 | - |
| created_at | 创建时间 | 构建任务的创建时间戳。 | Datetime | - | - | 不允许为空 | - |
| updated_at | 更新时间 | 构建任务状态或元数据最近更新的时间戳。 | Datetime | - | - | 不允许为空, 更新时自动更新 | - |
| finished_at | 完成时间 | 构建任务的完成时间戳。 | Datetime | - | - | 允许为空 | - |

### 3.3 Artifact（资产）

**说明**

`Artifact` 表是系统的核心数据表之一，用于记录所有由构建任务（`BuildTask`）生成的最终产物。这些产物是代码经过编译、链接后生成的二进制文件，例如可执行文件（`.exe`）、动态链接库（`.dll`、`.so`）或源代码包。

此表的设计遵循“元数据与实体分离”的原则。表中只存储产物的元数据信息，例如产物的名称、类型、大小以及用于校验内容完整性的摘要（`canonical_digest`）。而产物实体本身则存储在专门的文件存储系统或对象存储中，通过 `ArtifactLocation` 表进行关联。这种设计避免了数据库的膨胀，提高了查询效率和系统的可扩展性。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 约束条件 |
|---|---|---|---|---|---|
| artifact_id | 产物ID | 主键 | BIGINT UNSIGNED | 64位 | 主键、不为空 |
| build_id | 构建ID | 关联的构建任务ID。通过此ID，可以追溯到该产物是由哪个具体的构建任务生成的，包括其源代码、编译选项等信息。 | BIGINT UNSIGNED | 64位 | 外键, 不允许为空 |
| name | 名称 | 产物名称 | String | 255 | 不为空 |
| type | 类型 | 产物类型（exe、dll、so、source等） | Enum | - | 不为空 |
| canonical_digest | 规范内容摘要 | 产物内容的规范化摘要（如 `sha256:<HEX>`），用于内容寻址与一致性校验。 | String | 71 | 唯一，不为空 |
| size | 大小 | 产物大小（字节） | BigInt | - | 不为空 |
| created_at | 创建时间 | 创建时间 | Datetime | - | 不为空 |
| updated_at | 更新时间 | 产物元数据最近更新的时间戳。 | Datetime | - | 不允许为空, 更新时自动更新 |

**示例数据**

| artifact_id | build_id | name | type | canonical_digest | size | created_at |
|---|---|---|---|---|---|---|
| `art-a1b2c3d4` | `bld-e5f6g7h8` | `lib_math.so` | `so` | `sha256:123...abc` | 1048576 | `2025-11-05 10:00:00` |
| `art-b2c3d4e5` | `bld-f6g7h8i9` | `main_app.exe` | `exe` | `sha256:456...def` | 5242880 | `2025-11-05 11:30:00` |

---

## 4.报文配置管理

### 4.1 MessageFormat (报文格式定义)

**说明**

`MessageFormat` 表是报文格式的**核心元数据表**。它专注于记录特定版本报文的业务属性和身份信息，而将所有与物理存储相关的细节剥离出去。通过 `definition_digest_sha256` 字段，它与实际的物理文件（XML定义文件）建立逻辑关联。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| id | 报文格式ID | 报文格式定义的唯一标识；对应一份报文定义元数据实体。 | BIGINT UNSIGNED | 64位 | ≥0 | 主键，自动递增，不为空 | - |
| name | 报文格式名称 | 业务可读名称，用于展示、检索；在项目内唯一。 | VARCHAR | 255 | - | 不为空；唯一约束 `(name, version)` | - |
| description | 描述 | 对报文格式的详细描述，包含其应用场景、协议等。 | VARCHAR | 1024 | - | 可为空 | - |
| version | 版本号 | 标识报文格式的演进版本，遵循语义化版本规范。 | VARCHAR | 50 | 语义化版本 | 不为空，默认 `1.0.0` | - |
| status | 状态 | 生命周期状态。 | VARCHAR | 50 | `active`/`inactive`/`deprecated` | 默认 `active`，不为空 | - |
| definition_digest_sha256 | 定义文件摘要 | 源定义文件（如XML）内容的哈希（SHA-256），作为内容的唯一“指纹”。 | VARCHAR | 64 | 十六进制 | 不为空 | - |
| definition_size_bytes | 文件大小（字节） | 记录源定义文件内容的体积。 | BIGINT UNSIGNED | 64位 | ≥0 | 不为空 | - |
| created_by | 创建者ID | 创建该报文格式的用户的唯一标识符。 | BIGINT UNSIGNED | 64位 | ≥0 | 外键, 不为空 | 关联User表 |
| created_at | 创建时间 | 记录创建时间。 | Datetime | - | - | 不为空, 更新时自动更新 | - |
| updated_at | 更新时间 | 最近一次更新。 | Datetime | - | - | 不为空, 更新时自动更新 | - |

> 约束建议：
> - 索引：`(name, version)` 唯一索引；`definition_digest_sha256` 普通索引。

## 5.用户、角色、权限相关

> 适用范围：内部低码平台（单租户），采用全局身份 + 全局 RBAC 权限模型。遵循无会话、最小权限、JWT 无 tenant_id 的最佳实践（参考 Auth0 与 OWASP）。

### 5.1 User（用户）

**说明**

`User` 表是系统的**身份认证基础**，用于存储所有用户的核心身份信息。它为每个用户分配一个全局唯一的 `user_id`，并记录其用于登录的 `username` 和经过安全哈希处理的 `password_hash`。此表的设计遵循安全最佳实践，不存储明文密码，仅保存用于验证的哈希值。通过 `is_active` 字段，管理员可以方便地启用或禁用账户，控制用户对系统的访问权限。该表是整个权限系统（RBAC）的入口点，所有对系统资源的操作都需要首先通过此表进行身份验证。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| user_id | 用户ID | 用户的唯一标识符，全局主键。 | BIGINT UNSIGNED | 64位 | ≥0 | 主键, 不允许为空 | - |
| username | 用户名 | 全局唯一登录名。 | String | 100 | - | 全局唯一, 不允许为空 | - |
| password_hash | 加密密码 | 哈希后的密码，不存储明文。 | String | 255 | - | 不允许为空 | - |
| is_active | 激活状态 | 账户是否可用。 | Boolean | - | `true`, `false` | 不允许为空, 默认 `true` | - |
| created_at | 创建时间 | 记录创建时间 | Datetime | - | - | 不为空, 更新时自动更新 | - |
| updated_at | 更新时间 | 记录最后更新时间 | Datetime | - | - | 不为空, 更新时自动更新 | - |

### 5.2 Role（角色）

**说明**

`Role` 表定义了系统中的用户角色。每个角色代表一组权限的集合，通过将角色分配给用户，可以方便地管理用户的访问控制。这种基于角色的访问控制（RBAC）模型，简化了权限管理，提高了系统的可维护性和安全性。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| role_id | 角色ID | 角色的唯一标识符。 | BIGINT UNSIGNED | 64位 | ≥0 | 主键, 不允许为空 | - |
| role_name | 角色名称 | 角色名称（例如“管理员”、“开发者”、“访客”），全局唯一。 | String | 100 | - | 全局唯一, 不允许为空 | - |
| description | 描述 | 角色职责与权限范围说明。 | String | 500 | - | 允许为空 | - |
| created_at | 创建时间 | 记录创建时间。 | Datetime | - | - | 不为空, 更新时自动更新 | - |
| updated_at | 更新时间 | 最近更新时间。 | Datetime | - | - | 不为空, 更新时自动更新 | - |

### 5.3 Permission（权限）

**说明**

`Permission` 表定义了系统中的所有可用权限。每个权限代表一个特定的操作或对资源的访问权限。通过将权限分配给角色，可以精确地控制每个角色能够执行的操作，从而实现精细化的访问控制。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| permission_id | 权限ID | 权限的唯一标识符。 | BIGINT UNSIGNED | 64位 | ≥0 | 主键, 不允许为空 | - |
| permission_name | 权限名称 | 建议采用 `resource:action` 格式，如 `flow:create`、`user:delete`，全局唯一。 | String | 255 | - | 唯一, 不允许为空 | - |
| description | 描述 | 权限的详细说明。 | String | 500 | - | 允许为空 | - |
| category | 权限分类 | 便于分组展示的类别，如“流程管理”、“用户管理”。 | String | 100 | - | 允许为空 | - |
| created_at | 创建时间 | 记录创建时间 | Datetime | - | - | 不为空, 更新时自动更新 | - |
| updated_at | 更新时间 | 记录最后更新时间 | Datetime | - | - | 不为空, 更新时自动更新 | - |

### 5.4 UserRole（用户角色关联）

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| user_id | 用户ID | 关联到用户的全局唯一标识符。 | BIGINT UNSIGNED | 64位 | ≥0 | 联合主键, 外键, 不允许为空 | 关联 User |
| role_id | 角色ID | 关联到角色的唯一标识符。 | BIGINT UNSIGNED | 64位 | ≥0 | 联合主键, 外键, 不允许为空 | 关联 Role |
| created_at | 创建时间 | 记录创建时间 | Datetime | - | - | 不为空, 更新时自动更新 | - |

说明：用户的授权仅依赖全局角色集合。`(user_id, role_id)` 构成联合主键，确保一个用户不会重复关联同一个角色。

### 5.5 RolePermission（角色权限关联）

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| role_id | 角色ID | 指定哪个角色拥有特定权限。 | BIGINT UNSIGNED | 64位 | ≥0 | 联合主键, 外键, 不允许为空 | 关联 Role |
| permission_id | 权限ID | 指定角色拥有哪些权限。 | BIGINT UNSIGNED | 64位 | ≥0 | 联合主键, 外键, 不允许为空 | 关联 Permission |
| created_at | 分配时间 | 记录权限分配给角色的时间。 | Datetime | - | - | 不为空, 更新时自动更新 | - |

说明：`(role_id, permission_id)` 构成联合主键，确保一个角色不会重复关联同一个权限。

### 5.6 AuditLog（审计日志）

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| log_id | 日志ID | 审计日志的唯一标识符，自增。 | BIGINT UNSIGNED | 64位 | ≥0 | 主键, 自增, 不允许为空 | - |
| user_id | 操作用户ID | 执行操作的用户唯一标识符。对于系统自动触发的操作，可为空。 | BIGINT UNSIGNED | 64位 | ≥0 | 外键, 允许为空 | 关联 User |
| action_resource | 操作资源 | 被操作的资源类型，如 `User`, `Role`, `Flow`。 | String | 100 | - | 不允许为空 | - |
| action_type | 操作类型 | `CREATE`, `UPDATE`, `DELETE`, `LOGIN`, `GRANT` 等。 | String | 50 | 见取值 | 不允许为空 | - |
| target_resource_id | 目标资源ID | 被影响资源的主键或唯一标识。 | String | 255 | - | 不允许为空 | - |
| result | 操作结果 | `SUCCESS` 或 `FAILURE`。 | String | 20 | `SUCCESS`, `FAILURE` | 不允许为空 | - |
| details | 详细信息 | JSONB/JSON 格式，记录变更前后的数据快照、请求参数等。 | Object | - | - | 允许为空 | - |
| error_message | 错误信息 | 当 `result` 为 `FAILURE` 时，记录详细的错误原因。 | Text | - | - | 允许为空 | - |
| trace_id | 链路追踪ID | 用于关联分布式系统中的一系列操作，贯穿整个请求生命周期。 | String | 36 | - | 允许为空, 建议索引 | - |
| request_id | 请求ID | 单次 HTTP 请求的唯一标识符。 | String | 36 | - | 允许为空, 建议索引 | - |
| ip_address | IP地址 | 发起请求的客户端 IP 地址。 | String | 45 | - | 允许为空 | - |
| user_agent | 用户代理 | 发起请求的客户端 User-Agent。 | String | 512 | - | 允许为空 | - |
| created_at | 操作时间 | 记录日志写入时间。 | Datetime | - | - | 不为空, 更新时自动更新 | - |

说明：此表设计旨在提供更详细、更安全的审计追踪能力。

## 6.日志相关

### 6.1 FrontendLog（前端日志）

**说明**

`logs_frontend` 表用于存储前端浏览器控制台输出的所有日志信息。系统自动拦截前端的所有 console 方法（log、error、warn、info、debug、trace、table、dir、group、time、count、assert 等），通过 WebSocket 实时发送到后端并存入此表。此表为前端调试和问题追踪提供了集中的日志存储，支持 AI 分析和历史回溯。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| log_id | 日志ID | 日志记录的唯一标识符，自增。 | INTEGER | - | ≥0 | 主键, 自增, 不允许为空 | - |
| level | 日志级别 | 日志级别标签，从日志消息中自动解析。 | VARCHAR | 20 | `LOG`, `ERROR`, `WARN`, `INFO`, `DEBUG`, `TRACE`, `TABLE`, `DIR`, `GROUP`, `TIME`, `COUNT`, `ASSERT` 等 | 不允许为空 | - |
| message | 日志消息 | 日志的具体内容，已去除 ANSI 颜色码。 | TEXT | - | - | 不允许为空 | - |
| created_at | 创建时间 | 日志记录的时间戳（毫秒级 Unix 时间戳）。 | BIGINT | - | ≥0 | 不允许为空 | - |

**核心特性**

- **自动清理**: 查询接口会自动清理超过 3 分钟的旧日志，保持表数据量在合理范围。
- **节流控制**: 清理操作带有 5 秒节流，避免频繁查询导致高负载。
- **时序排序**: 查询结果按时间正序返回（旧→新），符合 AI 阅读习惯，便于理解因果关系。
- **批量写入**: 支持单条或批量日志写入，前端使用缓冲机制减少网络请求。

**API 接口**

- `GET /api/logs/frontend/query` - 查询前端日志列表（分页，自动清理旧数据）

**日志发送方式**

前端通过 WebSocket（socket.io）实时发送日志，事件名：`frontend-log`，数据格式：`{ logs: string[] }`

## 7.协同与版本控制相关

### 7.1 Commit (版本提交记录)

**说明**

`Commit` 表是版本控制系统的核心，用于记录每一次用户提交的变更。每次提交都代表了项目在某个时间点上的一个稳定状态，包含了作者、提交信息和父提交的引用，从而构成了一个完整的版本历史链。这使得团队能够追踪变更、回滚到任意版本，并支持多人协同开发。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| commit_id | 提交ID | 版本提交的唯一标识符。作为版本链中的一个节点，每次用户“发布”其修改时都会创建一个新的提交记录，用于追踪变更历史和支持回滚操作。 | BIGINT UNSIGNED | 64位 | ≥0 | 主键, 不允许为空 | - |
| author_id | 作者ID | 执行本次提交操作的用户的唯一标识符。用于追溯每次变更的责任人，是协同工作和审计功能的基础。 | BIGINT UNSIGNED | 64位 | ≥0 | 外键, 不允许为空 | 关联User表 |
| message | 提交信息 | 用户在提交时输入的描述性文本，用于说明本次变更的目的和主要内容。良好的提交信息是保证版本历史可读性的关键。 | String | 1024 | - | 不允许为空 | - |
| parent_commit_id | 父提交ID | 指向当前提交的前一个版本（父版本）的ID。通过该字段可以构建出完整的版本历史链条，支持版本回滚和历史追溯。对于项目的首次提交，该字段可以为空。 | BIGINT UNSIGNED | 64位 | ≥0 | 允许为空 | 关联Commit表 (自关联) |
| created_at | 创建时间 | 提交记录被创建的时间戳。精确记录了每次版本发布的时间点，用于按时间排序和展示历史记录。 | Datetime | - | - | 不为空, 更新时自动更新 | - |

### 7.2 AssetSnapshot (资产快照)

**说明**

`AssetSnapshot` 表用于在每次提交时，捕获项目中所有资产（如流程图、配置文件）的元数据快照。它将特定版本的资产与一次提交关联起来，记录了资产在那个时间点的名称、内容摘要和大小。通过这种方式，系统可以精确地重建任何历史版本，确保了版本控制的完整性和可追溯性。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| snapshot_id | 快照ID | 资产快照的唯一标识符。每个快照都代表一个特定资产在某次提交时的元数据。 | BIGINT UNSIGNED | 64位 | ≥0 | 主键, 不允许为空 | - |
| commit_id | 提交ID | 该快照所属的提交记录的唯一标识符。通过此字段，可以将多个资产的快照组织在一次提交中，形成一个完整的版本。 | BIGINT UNSIGNED | 64位 | ≥0 | 外键, 不允许为空 | 关联Commit表 |
| asset_id | 资产ID | 被快照的原始资产的唯一标识符。用于将快照与工作区中的实际资产关联起来。 | String | 36 | - | 不允许为空 | - |
| asset_type | 资产类型 | 资产的类型标识，如流程图、协议、函数等。 | String | 50 | - | 不允许为空 | - |
| asset_name | 资产名称 | 资产在提交时的名称。冗余存储该字段方便快速展示版本历史。 | String | 255 | - | 不允许为空 | - |
| canonical_digest_sha256 | 内容摘要 | 资产文件内容的SHA256哈希值，作为文件内容的唯一标识符，用于校验数据完整性和快速比较文件是否相同。 | String | 64 | - | 不允许为空 | - |
| size_bytes | 文件大小 | 资产文件的精确大小，单位为字节。用于资源管理和预估下载时间。 | Long | - | - | 不允许为空 | - |

### 7.3 Workspace (用户工作区)

**说明**

`Workspace` 表为每个用户提供了一个独立的工作区，用于隔离他们正在进行的修改。它记录了用户当前工作的基础版本，使得系统能够检测到与其他用户或主分支的冲突。这种设计是实现非阻塞、多人协同开发的关键，确保了每个用户都可以在一个安全、独立的环境中工作，而不会相互干扰。

| 字段 | 名称 | 含义 | 数据类型 | 长度 | 取值范围 | 约束条件 | 关联关系 |
|---|---|---|---|---|---|---|---|
| workspace_id | 工作区ID | 用户工作区的唯一标识符。每个用户在每个项目上都有一个独立的工作区，用于隔离不同用户的并发修改，是实现协同工作的基础。 | BIGINT UNSIGNED | 64位 | ≥0 | 主键, 不允许为空 | - |
| user_id | 用户ID | 该工作区所属用户的唯一标识符。 | BIGINT UNSIGNED | 64位 | ≥0 | 外键, 不允许为空 | 关联User表 |
| base_commit_id | 基础提交ID | 用户当前修改所基于的版本（提交）的ID。在用户执行“发布”操作时，系统会用此ID与项目最新的提交ID进行比较，以检测是否存在冲突。 | BIGINT UNSIGNED | 64位 | ≥0 | 不允许为空 | 关联Commit表 |
| created_at | 创建时间 | 工作区的创建时间戳。 | Datetime | - | - | 不为空, 更新时自动更新 | - |
| updated_at | 最后更新时间 | 工作区内容最后一次被修改的时间戳。可用于未来的功能扩展，例如自动保存或提示用户未保存的修改。 | Datetime | - | - | 不为空, 更新时自动更新 | - |

## 8. 统一存储策略与设计原则

本节阐述了一种统一的资产存储设计，旨在实现“单一事实来源”与“关注点分离”，构建一个可扩展、可维护且高效的系统。

### 8.1 分层解耦的存储架构

这是一种将**数据定义**、**元数据索引**和**物理位置**分离的分层设计：

- **权威来源 (Source of Truth)**: **资产文件**是唯一权威。
  - *例如：定义报文结构的 `XML` 文件，或定义业务逻辑的 `Flow` 文件。*
- **数据索引 (Index)**: **业务元数据表**（如 `MessageFormat`）作为资产的“索引”，存储核心业务属性和摘要信息，用于快速检索，但其内容非权威。
- **存储连接器 (Connector)**: **`AssetLocation` 表**是连接元数据与物理存储的“多态连接器”，通过 `(asset_id, asset_type)` 关联任何类型的资产。
- **物理存储 (Locator)**: **`StorageEndpoint` 表**统一管理所有外部存储后端（如 S3, MinIO, NFS），实现存储的“热插拔”。

**核心规则**：所有资产文件**必须**存储在外部系统中，数据库**禁止**存储二进制（BLOB）。

### 8.2 架构优势

采用此设计是为了获得以下核心优势：

- **保证数据一致性**: 资产文件是单一事实来源，彻底避免了数据库与文件内容不一致的风险。
- **实现极致的扩展性与解耦**:
  - **业务无关**: 数据库表结构与任何具体业务（报文格式、流程协议）完全解耦。
  - **轻松扩展**: 支持新资产类型（如 `TEST_CASE`）**无需修改表结构**，仅需在 `asset_type` 枚举中增加一项。
- **提升系统性能与可维护性**:
  - **数据库轻量化**: 剥离文件存储，保证数据库的高性能。
  - **职责清晰**: 执行引擎信任文件，管理平台利用元数据，各司其职。
  - **完整追溯**: 可追踪从源定义到衍生代码（如 `.h`, `.cpp`）的完整资产链路。

### 8.3 实施指南与高级策略

- **基础工作流**:
  1. **上传资产文件**至外部存储。
  2. **创建元数据记录**，并记录文件摘要（如 SHA256 哈希值）。
  3. **创建 `AssetLocation` 记录**，将元数据与一个或多个物理存储位置关联。

- **本地文件系统 (`localfs`) 作为存储的最佳实践**:
  - 当 `provider` 设置为 `localfs` 时，系统将使用服务器的本地文件系统作为存储后端。为确保系统的稳定性和可扩展性，应遵循以下实践：
    - **`base_uri` 格式**: `base_uri` 字段必须是一个标准的 `file` URI，指向服务器上的一个**绝对路径**。
      - **Linux/macOS 示例**: `file:///var/data/lowcode_assets/`
      - **Windows 示例**: `file://D:/data/lowcode_assets/`
    - **生产环境强烈建议**:
      - **使用挂载的共享存储**: 在生产或集群环境中，`base_uri` 指向的路径**不应该**是应用服务器的本地磁盘。而应是一个挂载到所有应用节点上的**共享网络文件系统**（如 NFS, GlusterFS, CephFS）或块存储卷（如 SAN）。
      - **原因**: 这可以避免单点故障，并确保无论请求被路由到哪个应用服务器实例，都能访问到一致的文件。它还简化了备份和灾难恢复。
    - **开发与单机部署**:
      - 在本地开发或单节点部署时，可以直接使用服务器上的一个普通目录。但这**不是**一个高可用或可扩展的方案，只适用于非关键业务场景。

- **实施高级策略**:
  - **数据冗余与灾备**: 为同一资产创建多个 `AssetLocation` 记录，指向不同的 `StorageEndpoint`。
  - **版本管理**:
    - **不可变版本**: 在元数据表中使用 `(name, version)` 唯一约束。
    - **版本标签**: 在 `AssetLocation` 中使用 `version_tag` 标记 `latest`, `stable` 等。
    - **完整历史**: 引入独立的 `AssetVersionHistory` 表进行复杂版本追溯。
  - **生命周期管理**: 使用 `AssetLocation` 中的 `decommissioned_at` 字段进行软删除和归档。
  - **数据完整性校验**: 在上传和下载时，务必使用元数据中存储的哈希值和文件大小进行校验。