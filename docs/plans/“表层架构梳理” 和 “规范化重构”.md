
**在不改动任何业务逻辑、不影响项目功能运行的前提下，对Vue项目进行“表层架构梳理”和“规范化重构”——只调整文件目录、命名规则、路由配置、模块引用方式这些“形式层面”的内容，让混乱的项目结构变清晰、命名变统一、模块拆分变合理，方便后续维护和协作，同时做到业务代码“零侵入”**。

简单说，你要的是“换架子不换内里”，既解决历史遗留的混乱问题，又规避业务代码改动带来的bug风险，这是大型多人经手项目重构的稳妥优先方案，非常合理。

我要一套可落地、无业务侵入的Vue项目规范化梳理方案，分核心维度逐步推进：

### 一、 第一步：统一命名规范（零业务侵入，先定规则再落地）
命名混乱是多人项目的重灾区，先统一所有命名规则，后续按规则批量整改，全程不改动业务代码逻辑，只改“名字”和“引用路径”。

#### 1.  核心命名原则（全局统一）
- 基本原则：**语义化清晰 + 风格统一 + 无歧义**，杜绝“拼音+英文”“随意缩写”“大小写混乱”等问题
- 禁用项：禁止使用 `aaa.vue`、`temp.js`、`utils1.js`、`myComponent.vue`（大小写混乱）、`用户管理.vue`（中文文件名）等无意义/不规范命名

#### 2.  各类型文件/资源命名规则
| 类型                | 命名风格                | 示例                          | 说明                                  |
|---------------------|-------------------------|-------------------------------|---------------------------------------|
| Vue组件（单文件）   | kebab-case（短横线）    | `user/list.vue`、`order/detail.vue` | 统一风格，便于全局搜索、引用          |
| 工具函数/JS模块     | camelCase（小驼峰）     | `formatDate.js`、`userApi.js`  | 语义化优先，一眼能识别功能            |
| 路由文件/配置文件   | kebab-case（短横线）    | `router-index.js`、`vue-config.js`（或小驼峰） | 配置类文件可灵活选择，核心是全局统一  |
| 目录文件夹          | kebab-case（短横线）     | `views/user`、`assets/images` | 统一风格，便于静态资源管理            |
| 图片/静态资源       | kebab-case（短横线）    | `avatar-default.png`、`btn-submit.svg` | 统一风格，便于静态资源管理            |
| 常量/枚举           | UPPER_CASE（大写下划线） | `const USER_STATUS = { ... }`  | 仅JS内部常量，不涉及文件命名          |

#### 3.  命名整改注意点
- 整改时：先批量收集所有不规范命名，按规则拟定新名称，再通过编辑器（VS Code）的“重命名文件”功能（F2）修改，**编辑器会自动更新项目内对应的引用路径**（避免手动改路径出错）
- 兜底：修改后全局搜索旧名称，确认无遗漏引用，确保项目能正常运行

### 二、 第二步：统一模块拆分（按业务/功能划分，无业务代码改动）
模块拆分混乱的核心是“划分标准不统一”（有的按页面拆、有的按功能拆、有的按组件类型拆），现在按“分层+分业务”的思路重新拆分，只移动文件、调整引用，不修改文件内业务逻辑。

#### 1.  整体目录架构（Vue2/Vue3通用，可按需微调）
```
src/
├── api/                # 全局统一接口请求（按业务拆分文件）
│   ├── user.js     # 用户相关接口
│   ├── order.js    # 订单相关接口
│   └── index.js        # 接口统一导出（便于全局引用）
├── assets/             # 静态资源（按类型拆分目录）
│   ├── images/         # 图片资源（可再按业务拆分）
│   ├── styles/         # 全局样式（公共样式、变量、重置样式等）
│   └── fonts/          # 字体文件
├── components/         # 全局公共组件（非业务专属，可复用）
│   ├── common/         # 基础通用组件（按钮、输入框、弹窗等）
│   └── business/       # 业务公共组件（跨页面复用的业务组件，如用户卡片、订单列表项等）
├── router/             # 路由配置（统一管理，按业务拆分模块）
│   ├── modules/        # 路由模块拆分（用户路由、订单路由等）
│   └── index.js        # 路由统一注册
├── store/              # 状态管理（Vuex/Pinia，按业务拆分模块）
│   ├── modules/        # 状态模块（user.js、order.js等）
│   └── index.js        # 状态统一注册
├── utils/              # 全局工具函数（按功能拆分文件）
│   ├── format.js       # 格式化工具（时间、金额等）
│   ├── request.js      # 请求封装（axios拦截等）
│   └── validate.js     # 校验工具（表单校验等）
├── views/              # 页面视图（核心：按业务模块拆分目录，一一对应路由）
│   ├── user/    # 用户管理业务模块
│   ├── order/   # 订单管理业务模块
│   │   └── components/
│   └── dashboard/      # 首页/工作台模块
├── hooks/              # Vue3专属：全局自定义hooks（按功能拆分）
├── layouts/            # 布局组件（全局布局、侧边栏、头部等）
├── App.vue             # 根组件（不改动业务，可微调布局引用）
└── main.js             # 入口文件（仅调整全局引用路径，不改动业务逻辑）
```

#### 2.  模块拆分核心规则
1.  **页面与业务强绑定**：`views/` 下的目录严格按业务模块划分（如用户管理、订单管理），每个业务目录下存放该业务的所有页面，以及该业务**专属组件**（`components/` 子目录），避免跨业务组件混乱引用
2.  **公共与私有隔离**：
    - 全局公共组件（如按钮、弹窗）放入 `src/components/`，供所有业务使用；
    - 业务专属组件（如仅用户管理页面使用的筛选组件）放入 `views/xxx/components/`，不污染全局组件库
3.  **功能模块单一职责**：`api/`、`utils/`、`store/modules/` 等目录下，每个文件只负责一个功能模块（如 `user.js` 只放用户相关接口），避免“大杂烩”文件
4.  **路由与页面对应**：`router/modules/` 下的路由模块，与 `views/` 下的业务目录一一对应（如 `user.js` 对应 `views/user/`），便于查找和维护

#### 3.  模块拆分落地步骤（无业务风险）
1.  先梳理现有项目的业务边界（明确有哪些核心业务模块，如用户、订单、商品等）
2.  按上述目录架构，在项目中先新建规范目录（不删除旧目录，避免出错）
3.  逐个业务模块，将对应的页面、组件、接口等文件**移动**到新目录
4.  通过编辑器自动更新文件内的引用路径（如 `import UserApi from '@/api/user'`）
5.  移动完成后，测试对应业务功能，确认无引用错误和功能异常
6.  所有模块迁移完成后，删除旧的混乱目录

### 三、 第三步：统一路由配置（规范化管理，无业务侵入）
路由混乱常见于“路由分散注册”“路径不统一”“命名无规则”，现在统一梳理，只调整路由配置结构和命名，不修改路由对应的页面组件和业务逻辑。

#### 1.  路由规范化规则
1.  **路由拆分**：按业务模块拆分到 `router/modules/` 目录，每个模块一个路由文件，最后在 `router/index.js` 统一导入注册
2.  **路径规则**：路由 `path` 统一使用 kebab-case 风格，与 `views/` 下的业务目录对应，示例：
    -  用户列表页面：`path: '/user/list'`（对应 `views/user/list.vue`）
    -  订单详情页面：`path: '/order/detail?id={id}'`
3.  **命名规则**：路由 `name` 统一使用 PascalCase 风格，与对应组件名称一致，示例：
    -  `name: 'UserList'`（对应 `user/list.vue`）
    -  `name: 'OrderDetail'`
4.  **懒加载统一**：所有路由组件统一使用懒加载，优化打包体积，格式统一：
    ```js
    // 统一格式，避免多种懒加载写法混乱
    const UserList = () => import('@/views/user/list.vue')
    ```
5.  **路由守卫统一**：全局路由守卫放在 `router/index.js`，业务专属路由守卫可在对应业务路由模块内定义，避免守卫逻辑混乱

#### 2.  路由配置示例
```js
// router/modules/user.js（用户业务路由模块）
export default [
  {
    path: '/user',
    name: 'User',
    redirect: '/user/list', // 默认重定向到用户列表
    component: () => import('@/layouts/DefaultLayout.vue'), // 全局布局
    children: [
      {
        path: 'list',
        name: 'UserList',
        component: () => import('@/views/user/list.vue'),
        meta: {
          title: '用户列表', // 统一面包屑、页面标题使用
        }
      },
      {
        path: 'detail',
        name: 'UserDetail',
        component: () => import('@/views/user/detail.vue'),
        meta: {
          title: '用户详情',
        }
      }
    ]
  }
]

// router/index.js（路由统一注册）
import Vue from 'vue'
import Router from 'vue-router'
// 导入所有业务路由模块
import userRouter from './modules/user'
import orderRouter from './modules/order'

Vue.use(Router)

const router = new Router({
  mode: 'history',
  base: process.env.BASE_URL,
  routes: [
    {
      path: '/',
      redirect: '/dashboard'
    },
    {
      path: '/dashboard',
      name: 'Dashboard',
      component: () => import('@/views/dashboard/index.vue')
    },
    // 合并业务路由
    ...userRouter,
    ...orderRouter
  ]
})

// 全局路由守卫（统一在这里配置）
router.beforeEach((to, from, next) => {
  // 业务逻辑不变，仅统一放置在这里
  document.title = to.meta.title || {系统名称}
  next()
})

export default router
```

### 四、 


#### 1.  统一使用绝对路径（别名引用）
Vue项目默认已配置 `@` 作为 `src/` 目录的别名，全局统一使用该别名引用文件，杜绝相对路径层级混乱。
-  规范写法：`import formatDate from '@/utils/format'`、`import UserList from '@/views/user/list'`
-  禁用写法：`import formatDate from '../../utils/format'`

#### 2.  统一模块导出/导入
-  对 `api/`、`utils/` 等公共模块，在目录下创建 `index.js` 做统一导出，便于集中引用
  ```js
  // api/index.js（统一导出）
  import userApi from './user'
  import orderApi from './order'

  export default {
    userApi,
    orderApi
  }

  // 组件内引用（简化写法，无需逐个导入）
  import api from '@/api'
  // 使用用户接口
  api.userApi.getUserList()
  ```
-  避免“单个组件多次导入同一模块”，统一在组件顶部集中导入，按“第三方库 → 全局公共模块 → 业务模块”的顺序排列，提升可读性

### 五、 关键落地保障（确保业务无影响）
1.  **不用备份不用推送**：在当前分支直接修改,且不用推送代码，避免影响其他同事的工作
2.  **小步迭代**：按“命名 → 模块拆分 → 路由 → 引用”的顺序，分模块逐步整改，整改一个模块测试一个模块，避免一次性大面积改动导致问题难以排查
3.  **利用工具提升效率**：使用VS Code的“批量重命名”“全局搜索替换”“自动更新引用”功能，减少手动操作错误
4.  **制定规范文档**：将上述命名、目录、路由规则整理成项目文档，提交到代码仓库，确保后续所有开发人员遵循统一规范，避免再次混乱
5.  **代码审查**：整改完成后，调用技能和MCP工具进行代码审查，确认规范落地到位，同时统一团队认知
