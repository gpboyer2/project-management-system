
```
前端 http://localhost:9300
后端 http://localhost:9200
chrome-devtools-mcp ： PengdeMacBook-Pro:cssc-node-view peng$ "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --remote-debugging-port=9222 --user-data-dir=/tmp/chrome-debug http://localhost:9300

DevTools listening on ws://127.0.0.1:9222/devtools/browser/35d11802-41f8-47b2-a723-8007c9c6edd1
```

以上我都已经给你启动好了，所有的依赖环境我都给你配好了, 现在：


# 路由驱动架构功能测试与完善

你拥有无限的 token 和资源，要调用所有的 MCP 和技能为我服务！

编码规则和约束：`CLAUDE.md`

---

## 一、任务背景

你正在参与一个名为"灵枢 IDE"的前端项目，项目使用 Vue 3 + Vue Router 4.x + Pinia + TypeScript 技术栈。项目最近完成了一次重要的架构改造：从"单路由 + Store 驱动"迁移到"路由驱动"架构。

### 实现计划文档（必读）

**在开始任何工作前，必须先阅读**：
`docs/plans/2026-01-09-router-driven-architecture.md`

该文档包含：
- 完整的架构改造计划（26 项任务）
- 每个任务的具体实现要求
- 架构约束和设计原则
- 代码结构规范

**工作前提**：所有测试和验证必须基于该文档中定义的架构原则进行，不得偏离。

### 核心架构原则

- 路由是唯一真理来源（Single Source of Truth）
- 所有导航通过 `router.push` 实现
- IDE 模块路由格式：`/#/editor/ide/:type/:id?params`
- Store 仅保存 UI 状态，数据由独立的缓存层管理
- Tab 系统是路由栈的可视化表现

### 项目工作目录

`/Users/peng/Desktop/Project/alpha-coda/cssc-node-view/client`

---

## 二、可用资源（MCP 与技能）

你的环境配备了完整的 MCP 服务和 Superpowers 技能，必须充分利用：

### 必须使用的技能（按优先级）

| 场景 | 必须调用的技能 |
|------|---------------|
| 开始任何测试前 | `superpowers:systematic-debugging` |
| 需要修复发现的 bug | `superpowers:systematic-debugging` |
| 需要编写测试用例 | `superpowers:test-driven-development` |
| 不确定如何实现某功能 | `superpowers:brainstorming` |
| 发现架构问题需要规划 | `superpowers:writing-plans` |
| 完成功能需要代码审查 | `superpowers:requesting-code-review` |
| 测试完成后验证 | `superpowers:verification-before-completion` |

### 必须使用的 MCP 工具

| 用途 | MCP 工具 |
|------|----------|
| 浏览器自动化测试 | **`chrome-devtools` MCP**（必须使用） |
| 查看项目结构 | `mcp__zread__get_repo_structure` |
| 读取远程文件 | `mcp__zread__read_file` |
| 搜索代码 | `mcp__zread__search_doc` |
| 截图分析测试结果 | `mcp__zai-mcp-server__analyze_image` |

### chrome-devtools-mcp MCP 自行测试（特别重要）

**核心原则**：AI 必须调用 `chrome-devtools` MCP 自行进行功能测试，减少用户参与。

**重要声明**：`chrome-devtools` 是本项目的核心测试工具，AI 必须熟练使用其提供的所有功能，包括但不限于：
- 导航到指定 URL
- 点击页面元素
- 输入文本
- 截取页面截图
- 获取页面内容
- 执行 JavaScript 代码

**必须使用 chrome-devtools-mcp MCP 的场景**：

1. **启动 dev 服务后** - 自动打开浏览器访问应用
2. **路由测试** - 自动导航到各个路由页面
3. **功能验证** - 自动点击、输入、验证结果
4. **截图诊断** - 发现问题时自动截图分析

**chrome-devtools-mcp MCP 调用示例**：

```
// 打开浏览器并访问应用
navigate("http://localhost:9300")

// 点击导航项
click("text=仪表板")

// 验证元素存在
assertElementExists("text=通信节点")

// 截图保存
screenshot({ path: "test-result.png" })
```

**测试流程要求**：

1. dev 服务启动后，立即调用 `chrome-devtools` MCP 打开浏览器
2. 按照测试用例自动执行操作
3. 遇到问题时自动截图并分析
4. 将测试结果反馈给主 AI

**禁止**：
- **禁止要求用户手动点击浏览器测试**
- **禁止跳过 chrome-devtools-mcp MCP 自动测试**
- **禁止使用其他方式代替 chrome-devtools-mcp MCP 进行浏览器测试**

---

## 三、工作模式：主从代理协作

**核心原则**：你是主 AI，负责监督协调。具体执行工作交给子代理完成。

### 工作流程

```
主 AI（你）
  │
  ├─→ 1. 调用 Task 工具启动子代理
  │     ├─ subagent_type: general-purpose（拆解任务）
  │     ├─ subagent_type: Explore（探索代码）
  │     └─ subagent_type: code-reviewer（审查代码）
  │
  ├─→ 2. 等待子代理反馈结果
  │
  ├─→ 3. 评估结果，决定下一步
  │     ├─ 结果正确 → 汇总报告
  │     ├─ 需要修复 → 调用修复子代理
  │     └─ 需要深入 → 调用专业子代理
  │
  └─→ 4. 持续监督直到任务完成
```

### 子代理类型与用途

| 子代理类型 | 用途 | 调用时机 |
|-----------|------|----------|
| general-purpose | 拆解复杂任务、多步骤任务 | 任务开始时 |
| Explore | 快速探索代码库、查找文件 | 需要了解代码结构时 |
| code-reviewer | 代码审查、发现问题 | 完成功能后 |
| Plan | 设计实现方案 | 发现架构问题需要规划时 |

### 调用示例

```typescript
// 拆解任务
Task({
  subagent_type: "general-purpose",
  prompt: "分析路由驱动架构，拆解为可独立验证的子任务，每个子任务要有明确的验收标准"
})

// 探索代码
Task({
  subagent_type: "Explore",
  prompt: "找出所有路由守卫的位置和逻辑，thoroughness: very high"
})

// 审查代码
Task({
  subagent_type: "superpowers:code-reviewer",
  prompt: "审查路由配置和数据加载逻辑，关注时序问题"
})
```

### 主 AI 职责

- 定义任务目标和验收标准
- 启动合适的子代理
- 评估子代理反馈
- 决策下一步行动
- 汇总最终报告

### 子代理职责

- 执行具体任务
- 反馈执行结果
- 提供详细日志
- 遇到问题主动上报

### 子代理可用技能

子代理在执行任务时，可以使用以下三个技能（通过 Skill 工具调用）：

| 技能 | 功能 | 调用时机 | 输出 |
|------|------|----------|------|
| `cc:lint` | 修复 lint 和 build 错误 | 代码修改后、提交前 | 修复报告 |
| `cc:commit` | 生成 git commit 消息 | 需要提交代码时 | commit 消息（不提交） |
| `cc:review` | 代码和业务审查 | 需要审查 git 变动时 | 审查报告 |

#### cc:lint 使用规范

```typescript
// 子代理调用
Skill({
  skill: "cc:lint"
})
```

**执行内容**：
- 前端和 server 端的 lint 检查
- TypeScript 类型检查
- 自动修复可修复的错误

**输出要求**：
- 报告修复的错误数量
- 列出无法自动修复的问题（如有）
- 确认 lint 是否通过

#### cc:commit 使用规范

```typescript
// 子代理调用
Skill({
  skill: "cc:commit"
})
```

**执行内容**：
- 读取 git status 和暂存区更改
- 分析 diff 和最近提交记录
- 生成符合规范的 commit 消息

**输出要求**：
- 完整的 commit 消息
- 符合项目 commit 规范
- **禁止包含任何 AI 签名**

**严格约束**：
- **允许执行 git commit**，生成消息后自动提交
- **绝对禁止执行 git push**，任何情况下都不允许推送
- **禁止输出 AI 签名**，以下内容绝对不允许出现在 commit 消息中：

```
🤖 Generated with [Claude Code](https://claude.com/claude-code)
Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```

**签名检查脚本**（输出前必须执行）：
```bash
# 检查生成的消息是否包含 AI 签名
echo "$COMMIT_MSG" | grep -q "Claude Code" && { echo "错误：包含 AI 签名"; exit 1; }
echo "$COMMIT_MSG" | grep -q "Co-Authored-By" && { echo "错误：包含 AI 签名"; exit 1; }
echo "$COMMIT_MSG" | grep -q "claude.com/claude-code" && { echo "错误：包含 AI 签名"; exit 1; }
```

#### cc:review 使用规范

```typescript
// 子代理调用
Skill({
  skill: "cc:review"
})
```

**执行内容**：
- 审查本次 git 变动
- 检查代码质量和业务逻辑
- 发现潜在问题和优化建议

**输出要求**：
- 列出修改的文件清单
- 指出潜在问题和风险
- 提供优化建议

**子代理调用示例**：
```typescript
// 完整流程：修复 → 审查 → 生成 commit 消息
Task({
  subagent_type: "general-purpose",
  prompt: `
    1. 调用 cc:lint 修复所有 lint 错误
    2. 调用 cc:review 审查代码改动
    3. 调用 cc:commit 生成 commit 消息
    4. 汇总所有结果并反馈给主 AI
  `
})
```

### 禁止事项

1. 禁止主 AI 亲自执行可委托给子代理的任务
2. 禁止同时启动超过 3 个子代理（避免混乱）
3. 禁止跳过子代理反馈直接下结论
4. 禁止子代理修改核心架构（需主 AI 决策）
5. **禁止执行 git push**，任何情况下都不允许推送代码

### 子代理 Prompt 模板

调用子代理时，使用以下模板确保输出符合预期：

#### general-purpose（任务拆解）

```
分析路由驱动架构，按以下格式输出：

**子任务列表**
1. [任务名称] - 描述 - 验收标准 - 优先级(P0/P1/P2/P3)
2. ...

**依赖关系**
- 任务2 依赖 任务1
- ...

**可并行任务**
- 任务1、任务3 可并行执行
- ...
```

#### Explore（代码探索）

```
探索目标：[具体目标]
探索深度：quick/medium/very thorough

输出格式：
**找到的文件**
- 文件路径: 功能说明

**关键代码位置**
- 功能点: 文件路径:行号

**潜在问题**
- 描述: 位置: 严重程度
```

#### code-reviewer（代码审查）

```
审查范围：[具体范围]
关注重点：[时序/安全/性能/架构]

输出格式：
**审查结果**
- 文件:行号 - 问题类型 - 问题描述 - 建议修改

**风险评估**
- 高风险问题: [数量]个
- 中风险问题: [数量]个
- 低风险问题: [数量]个
```

### 子代理输出评估标准

主 AI 必须按以下标准评估子代理输出：

| 评估项 | 合格标准 | 不合格标准 |
|--------|----------|------------|
| 完整性 | 包含结果、问题、建议 | 只有结果无分析 |
| 具体性 | 有文件路径和行号 | 只有模糊描述 |
| 可操作性 | 有具体修复方案 | 只有抽象建议 |
| 格式规范 | 符合输出模板 | 格式混乱 |

**不合格处理**：
- 第一次不合格 → 要求子代理重新执行，明确指出缺失项
- 第二次不合格 → 更换子代理类型或主 AI 亲自处理

### 失败处理机制

```
子代理失败
    │
    ├─→ 执行超时
    │     └─→ 续用 task_id 获取结果，最多等待3次
    │
    ├─→ 输出异常
    │     └─→ 分析错误信息，调整 prompt 重新调用
    │
    └─→ 连续2次失败
          └─→ 向用户报告，附上失败日志和建议方案
```

### 任务优先级规则

发现问题时，按以下优先级处理：

| 优先级 | 定义 | 示例 | 处理方式 |
|--------|------|------|----------|
| P0 | 阻塞性，功能完全不可用 | 页面空白、无接口请求 | 立即停止其他任务，优先修复 |
| P1 | 严重，核心功能受影响 | Tab 不更新、数据加载失败 | 修复后继续测试 |
| P2 | 一般，次要功能问题 | 拖拽排序异常 | 记录后继续测试，也要修复 |
| P3 | 轻微，体验问题 | 样式细节、文案错误 | 记录，也要修复 |

### 并行执行策略

**可并行**（同时执行）：
- 代码审查（不同模块）
- 静态检查（lint + typecheck）
- 独立功能测试

**必须串行**（按顺序执行）：
- 架构探索 → 任务拆解 → 执行
- 代码修复 → 验证测试
- 有依赖关系的子任务

### 用户交互时机

**必须用户参与**：
1. P0 级问题修复确认（影响重大时）

**AI 自主决策**：
1. 检查并启动 dev 服务（如未启动）
2. 调用 `chrome-devtools` MCP 自动进行浏览器测试
3. 子代理类型选择
4. 任务优先级排序
5. 修复方案设计
6. 测试步骤执行
7. 报告内容生成

**可选用户确认**（AI 可自主决定）：
1. P1/P2 级问题修复方案
2. 测试顺序调整
3. 子代理重试策略

---

## 四、核心功能验证清单

### 4.1 路由系统验证

必须验证的所有路由和对应各个状态下的格式，验收标准：

1. 所有路由能正确匹配对应的组件
2. 无效的路由参数能被守卫拦截并重定向
3. 直接访问 URL 能正确加载数据

### 4.2 Tab 工作台验证

验收目标：

- Tab 列表反映访问过的路由栈
- 点击 Tab 能切换路由
- 关闭 Tab 能正确跳转到相邻 Tab 或首页
- 支持 Tab 拖拽排序
- 支持右键菜单（关闭、关闭其他、关闭右侧、关闭所有）

### 4.3 数据加载验证

验收目标：

- 支持五种资源类型的数据加载
- 缓存机制正常工作
- 数据不存在时自动跳转到列表页
- 加载状态和错误状态正确显示

### 4.4 导航验证

验收目标：

- 树节点点击使用路由导航
- 不再使用旧的导航方法
- 导航后 Tab 正确更新

### 4.5 仪表板验证

验收目标：

- 并行加载各类资源统计数据
- 点击卡片跳转到对应列表页
- 加载状态正确显示

---

## 五、截图目录规范

### 截图目录位置

`test-screenshots/router-driven-[日期]/`

### 截图文件命名规范

格式：`序号-场景名称-状态.png`

示例：
- `01-dashboard-home-success.png` - 仪表板首页（成功）
- `02-tab-create-error.png` - Tab创建（错误场景）
- `03-route-navigation-success.png` - 路由导航（成功）

### 截图场景清单

必须截图的场景：

| 序号 | 场景 | 文件名示例 | 说明 |
|------|------|------------|------|
| 1 | 欢迎页 | 01-welcome-page.png | 首次访问应用 |
| 2 | 仪表板 | 02-dashboard.png | 统计卡片显示 |
| 3 | 节点列表 | 03-node-list.png | 通信节点列表页 |
| 4 | 接口列表 | 04-interface-list.png | 接口列表页 |
| 5 | 逻辑列表 | 05-logic-list.png | 逻辑列表页 |
| 6 | ICD列表 | 06-icd-list.png | ICD配置列表页 |
| 7 | 协议包列表 | 07-packet-list.png | 协议包列表页 |
| 8 | Tab切换 | 08-tab-switch.png | Tab切换状态 |
| 9 | 路由导航 | 09-route-navigation.png | 路由跳转过程 |
| 10 | 错误场景 | 10-error-scenario.png | 发现的错误（如有） |

### 截图保存要求

1. **及时保存**：每个测试场景完成后立即截图
2. **命名规范**：严格按照命名规范命名
3. **状态标识**：成功/失败在文件名中体现
4. **问题描述**：失败截图需在报告中对应说明
5. **对比验证**：修复后同一场景重新截图对比

### 截图在报告中的引用

在测试报告中引用截图：

```markdown
### 测试截图

#### 场景1：仪表板首页
![仪表板](test-screenshots/router-driven-2026-01-10/02-dashboard.png)

#### 场景2：Tab切换（修复前）
![Tab切换-修复前](test-screenshots/router-driven-2026-01-10/08-tab-switch-before.png)

#### 场景2：Tab切换（修复后）
![Tab切换-修复后](test-screenshots/router-driven-2026-01-10/08-tab-switch-after.png)
```

---

## 六、测试执行流程

### 第零步：阅读实现计划（必做）

**在执行任何测试前**，先调用子代理读取并分析实现计划：

```
Task({
  subagent_type: "general-purpose",
  prompt: "阅读 docs/plans/2026-01-09-router-driven-architecture.md，提取：1. 核心架构约束 2. 关键实现要求 3. 测试验收要点"
})
```

### 第一步：代码审查

1. 检查路由配置
2. 检查路由守卫
3. 检查数据加载层
4. 检查核心组件
5. 检查缓存工具

### 第二步：静态代码检查

执行命令：`/cc:lint`

如果有错误，必须先修复再继续。

### 第三步：启动开发环境

1. 检查服务是否就绪（访问 `http://localhost:9300`）
2. 如未就绪，AI 自行启动 dev 服务（后台运行）：
   ```bash
   cd client && pnpm dev
   ```
3. 确认服务启动成功并检查服务地址

### 第四步：功能测试

**调用 `chrome-devtools` MCP 自行进行浏览器测试**：

1. **路由访问测试** - 验证所有定义的 URL 格式能正确访问
2. **Tab 交互测试** - 验证 Tab 的创建、切换、关闭、右键菜单
3. **浏览器导航测试** - 验证前进、后退、直接输入 URL
4. **数据加载测试** - 验证数据显示、加载状态、错误处理

**测试步骤**：
```
1. 调用 chrome-devtools-mcp MCP 打开浏览器
2. 访问 http://localhost:9300
3. 依次执行测试用例
4. 遇到问题时自动截图
5. 记录测试结果
```

**禁止**：
- 禁止要求用户手动点击浏览器测试
- 禁止跳过 `chrome-devtools` MCP 自动测试

### 第五步：问题分析与修复

如果发现任何问题：

1. 调用 `superpowers:systematic-debugging` 技能
2. 在关键位置添加 `console.log` 追踪问题
3. 调用 `chrome-devtools` MCP 重新测试并截图验证
4. 分析根因并修复
5. 再次调用 `chrome-devtools` MCP 验证修复效果

重复此过程直到所有问题解决。

---

## 七、常见问题诊断

### 6.1 页面空白且无接口请求（P0 级）

**现象**：访问页面后完全空白，浏览器 Network 面板没有任何 API 请求

**诊断流程**（按顺序执行）：

1. **验证路由匹配**
   - 检查当前 URL 是否匹配已定义的路由规则
   - 检查路由组件是否正确导入和注册
   - 添加日志确认路由守卫是否被触发

2. **验证组件渲染**
   - 检查目标组件的 `v-if` 条件是否满足
   - 检查父组件是否正确渲染
   - 确认组件是否在正确的 `<router-view>` 中

3. **验证数据加载触发**
   - 检查 `loadData` 是否被调用
   - 检查调用时机（onMounted、watch 等）
   - 确认路由参数是否正确读取

4. **验证路由守卫逻辑**
   - 检查 beforeEach 是否错误拦截
   - 检查是否有重定向循环
   - 确认守卫中的异步操作是否完成

**调试日志添加位置**：
- 路由守卫入口
- 组件 onMounted
- loadData 函数首行
- 所有条件分支

**调试代码模板**：

```typescript
// 路由守卫中
router.beforeEach((to, from, next) => {
  console.log('[路由守卫]', { to: to.path, from: from.path });
  // ... 守卫逻辑
});

// 组件 onMounted
onMounted(() => {
  console.log('[组件挂载]', editorType.value, route.params);
  loadData();
});

// loadData 首行
async function loadData() {
  console.log('[开始加载数据]', { type: editorType.value, id: route.params.id });
  // ... 加载逻辑
}

// 条件分支
if (someCondition) {
  console.log('[条件判断]', { someCondition, value: someValue });
}
```

### 6.2 其他常见问题

### 示例1：路由无法匹配

- 现象：访问特定 URL 显示 404
- 处理：检查路由定义、守卫拦截、参数匹配规则

### 示例2：Tab 不更新

- 现象：导航后 Tab 没有增加
- 处理：检查路由监听、过滤条件、状态同步

### 示例3：数据加载失败

- 现象：页面显示空白或加载失败
- 处理：检查 API 映射、响应格式、错误处理

---

## 八、验收标准

### 完整性验收

所有以下项目必须通过：

- 路由系统能正确匹配所有定义的 URL 格式
- Tab 工作台能正确反映当前访问状态
- 数据加载层能正确加载所有类型的数据
- 缓存机制正常工作，重复访问不走 API
- 资源浏览器导航使用路由
- 仪表板能显示统计数据并跳转
- 列表页能显示列表并支持点击跳转
- 浏览器前进/后退按钮正常工作
- lint 检查通过
- build 构建成功

### 代码质量验收

- 所有新增代码符合项目规范
- 样式统一维护在 `index.scss` 中
- 组件内不写内联样式
- 变量命名使用 `snake_case`
- 注释使用中文
- 无 console 错误或警告

---

## 九、输出格式

在每次迭代结束时，按以下格式输出：

```markdown
## 测试报告 - [日期]

### 已验证功能
- [功能1]：状态 ✅/❌
- [功能2]：状态 ✅/❌
...

### 发现的问题
1. [问题描述]
   - 严重程度：P0/P1/P2/P3
   - 复现步骤：...
   - 当前状态：已修复/修复中/待修复

### 代码变更
- 修改文件：[文件路径]
- 变更说明：...

### 下一步计划
- [待完成任务]
```

---

## 十、重要提醒

### 禁止事项

1. 禁止在没有完全理解依赖关系时进行大规模重构
2. 禁止跳过验证直接声称功能正常
3. 禁止使用项目不支持的代码模式
4. 禁止修改核心架构而不向用户确认
5. **绝对禁止执行 git push**，任何情况下都不允许推送代码
6. **禁止在 commit 消息中包含 AI 签名**，包括但不限于：
   - `🤖 Generated with [Claude Code](https://claude.com/claude-code)`
   - `Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>`
   - 任何包含 "Claude Code"、"claude.com/claude-code"、"Co-Authored-By" 的内容

### 必须遵守

1. 遵循 `CLAUDE.md` 中的所有编码规范
2. 遇到不确定的情况先向用户说明
3. 每次修复后要求用户重新测试
4. 记录所有问题和修复过程

---

**请按照本提示词的指导，开始对路由驱动架构功能进行全面测试和完善。如有任何疑问，请先询问用户。**

---

# 附录：时序状态管理

## 一、时序状态概念

在前端 IDE 项目中，时序状态是指随时间推移而变化的有序状态集合，包括：

1. **访问时序**：用户访问页面的先后顺序
2. **Tab 栈时序**：Tab 的创建和销毁顺序
3. **状态依赖时序**：数据加载 → 渲染 → 交互的顺序
4. **缓存时序**：数据的创建、读取、过期顺序

## 二、时序状态的核心组件

### 2.1 访问历史时序

验收要点：

- 访问 A → B → C，Tab 顺序应为 A, B, C
- 访问 A → B → A，Tab 顺序应为 A, B（不重复）
- 关闭 B，当前为 B 时应跳转到 C，而非 A

### 2.2 路由守卫时序

验收要点：

- 无效类型直接重定向，不调用 API
- 数据不存在重定向到列表页，不陷入循环
- 列表页直接放行，不阻塞

### 2.3 数据加载时序

验收要点：

- 缓存命中时，直接返回，不显示 loading
- 缓存未命中时，显示 loading，请求完成后隐藏
- API 失败时，显示错误，自动跳转到列表页
- 错误状态下，用户再次操作能触发重新加载

### 2.4 缓存时序

验收要点：

- 首次访问创建缓存
- 5分钟内再次访问，使用缓存
- 超过5分钟，缓存过期，重新请求
- 刷新操作清除缓存并重新加载

## 三、时序状态测试方法

### 时序冲突检测

常见时序冲突场景：

- **快速连续点击** → 检测 Tab 是否按序创建
- **快速点击关闭** → 检测跳转目标是否正确
- **浏览器后退/前进** → 检测 Tab 和路由是否同步
- **异步加载期间的导航** → 检测是否有并发问题

## 四、时序状态修复原则

### 4.1 时序优先级

优先级从高到低：

1. 用户主动操作（点击、输入）
2. 浏览器导航（前进/后退/刷新）
3. 路由守卫拦截
4. 异步数据加载
5. 缓存清理

### 4.2 时序同步要点

必须保持同步的状态对：

1. 当前路由 ↔ Tab 高亮状态
2. 访问历史 ↔ Tab 列表
3. 加载状态 ↔ UI 加载状态
4. 数据 ↔ 缓存内容

### 4.3 时序异常处理

时序异常场景处理：

1. **并发请求冲突** → 取消旧请求，保留最新请求
2. **路由跳转中断** → 检查组件状态再更新
3. **缓存时序错乱** → 使用原子操作
4. **时序死锁** → 添加超时机制

## 五、时序状态验收清单

时序一致性验收：

- Tab 打开顺序与访问顺序一致
- 当前路由与高亮 Tab 一致
- 关闭 Tab 后跳转目标正确
- 快速操作不产生时序混乱
- 浏览器前进/后退与 Tab 同步
- 异步加载期间切换页面正常
- 缓存过期后自动重新加载
- 错误状态能恢复到正常时序
