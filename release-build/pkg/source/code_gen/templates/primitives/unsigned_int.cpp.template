{#
UnsignedInt 类型内联实现

模板变量:
  field_name - 字段名称
  has_range - 是否有范围验证
  is_single_range - 是否为单范围
  ranges - 范围数组
#}
{# 解析模式：根据 byte_length 选择最合适的底层无符号整数类型。
   1 -> uint8_t
   2 -> uint16_t
   4 -> uint32_t
   8 -> uint64_t
   其它情况退化为 uint64_t（协议配置如果写错，就让问题暴露出来）。 #}
{% set cpp_type = "uint64_t" %}
{% if byte_length == 1 %}
{%   set cpp_type = "uint8_t" %}
{% elif byte_length == 2 %}
{%   set cpp_type = "uint16_t" %}
{% elif byte_length == 4 %}
{%   set cpp_type = "uint32_t" %}
{% elif byte_length == 8 %}
{%   set cpp_type = "uint64_t" %}
{% endif %}
{
    {{ cpp_type }} {{ field_name }}_raw = 0;
    DeserializeResult res = deserialize_unsigned_int_generic<{{ cpp_type }}>(ctx, {{ field_name }}_raw);
    if (!res.is_success()) return res;
    {% if has_range and is_single_range %}
    if ({{ field_name }}_raw < {{ ranges[0].min }} || {{ field_name }}_raw > {{ ranges[0].max }}) {
        return DeserializeResult(INVALID_VALUE, "{{ field_name }} out of range", 0);
    }
    {% elif has_range %}
    // 多范围验证（内联范围数据）
    static const std::vector<std::pair<uint64_t, uint64_t>> {{ field_name }}_ranges = {
        {% for range in ranges %}
        { {{ range.min }}, {{ range.max }} }{% if not loop.last %},{% endif %}
        {% endfor %}
    };
    if (!validate_multi_range<uint64_t>(static_cast<uint64_t>({{ field_name }}_raw), {{ field_name }}_ranges)) {
        return DeserializeResult(INVALID_VALUE, "{{ field_name }} out of range", 0);
    }
    {% endif %}
    {{ result_prefix }}.{{ field_name }} = {{ field_name }}_raw;
}
