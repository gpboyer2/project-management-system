{#
分发器头文件模板
模板变量:
  protocol_name - 分发器名称
  PROTOCOL_NAME_UPPER - 分发器名称大写
  namespace - 命名空间名称
  dispatch_field - 分发字段名称
  dispatch_cpp_type - 分发字段 C++ 类型
  dispatch_offset - 分发字段偏移量
  dispatch_size - 分发字段大小（字节）
  dispatch_byte_order - 分发字段字节序
  default_byte_order - 默认字节序枚举值
  framework_relative_path - 框架头文件相对路径（默认 './'）
  messages - 子协议信息数组，每个元素包含：
     - id_value: MessageID 数值
     - id_hex: MessageID 十六进制字符串
     - enum_name: 枚举成员名（如 MSG_LOGIN_REQUEST）
     - protocol_name: 子协议名称
     - result_type: 结果结构体类型名
     - member_name: union 成员名
     - header_file: 头文件名
  has_messages - 是否有子协议
#}
#ifndef {{ PROTOCOL_NAME_UPPER }}_DISPATCHER_H
#define {{ PROTOCOL_NAME_UPPER }}_DISPATCHER_H

#include <memory>
#include "{{ framework_relative_path | default('./') }}protocol_parser_framework/protocol_common.h"
{% for msg in messages %}
#include "./{{ msg.header_file }}"
{% endfor %}

namespace {{ namespace }} {

// ============================================================================
// MessageType 枚举 - 定义所有支持的报文类型
// ============================================================================
enum {{ protocol_name }}MessageType {
    {{ PROTOCOL_NAME_UPPER }}_MSG_UNKNOWN = 0,
{% for msg in messages %}
    {{ msg.enum_name }} = {{ msg.id_value }}{% if not loop.last %},{% endif %}

{% endfor %}
};

// ============================================================================
// 分发器结果结构体
// 使用 std::shared_ptr<MessageBase> 实现多态存储
// 优点：自动生命周期管理、类型安全、支持 C++11
// ============================================================================
struct {{ protocol_name }}DispatcherResult {
    {{ protocol_name }}MessageType messageType;  // 当前报文类型
    {{ dispatch_cpp_type }} {{ dispatch_field }};  // 原始 MessageID 值

    // 统一持有的智能指针（指向具体子协议结果）
    std::shared_ptr<MessageBase> data;

    {{ protocol_name }}DispatcherResult()
        : messageType({{ PROTOCOL_NAME_UPPER }}_MSG_UNKNOWN)
        , {{ dispatch_field }}(0)
        , data(nullptr) {}

    // 辅助方法：类型安全的获取具体类型指针
    template<typename T>
    T* as() {
        return static_cast<T*>(data.get());
    }

    template<typename T>
    const T* as() const {
        return static_cast<const T*>(data.get());
    }

    // 辅助方法：获取具体类型的智能指针
    template<typename T>
    std::shared_ptr<T> asShared() const {
        return std::static_pointer_cast<T>(data);
    }

    // 辅助方法：检查是否有数据
    bool hasData() const {
        return data != nullptr;
    }
};

// ============================================================================
// 函数声明
// ============================================================================

/**
 * 反序列化函数（二进制 → 结构体）
 * 自动识别 MessageID 并分发到对应的子协议解析器
 *
 * @param data 原始二进制数据
 * @param length 数据长度
 * @param result 输出结果结构体
 * @param byte_order 字节序（默认: {{ default_byte_order }}）
 * @return 解析结果
 */
DeserializeResult deserialize_{{ protocol_name }}Dispatcher(
    const uint8_t* data,
    size_t length,
    {{ protocol_name }}DispatcherResult& result,
    ByteOrder byte_order = {{ default_byte_order }}
);

/**
 * 序列化函数（结构体 → 二进制）
 * 根据 messageType 选择对应的子协议序列化器
 *
 * @param data 输入结构体
 * @param buffer 输出缓冲区
 * @param buffer_size 缓冲区大小
 * @param byte_order 字节序（默认: {{ default_byte_order }}）
 * @return 序列化结果
 */
SerializeResult serialize_{{ protocol_name }}Dispatcher(
    const {{ protocol_name }}DispatcherResult& data,
    uint8_t* buffer,
    size_t buffer_size,
    ByteOrder byte_order = {{ default_byte_order }}
);

/**
 * 获取 MessageType 的字符串表示
 *
 * @param type 报文类型枚举值
 * @return 类型名称字符串
 */
const char* get_{{ protocol_name }}MessageTypeName({{ protocol_name }}MessageType type);

} // namespace {{ namespace }}

#endif // {{ PROTOCOL_NAME_UPPER }}_DISPATCHER_H
